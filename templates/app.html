{% extends "base.html" %}

{% block title %}AnonShare - Transfer{% endblock %}

{% block extra_css %}
<style>
    body { padding-top: 80px; }
    
    .app { max-width: 900px; margin: 0 auto; margin-top: 75px; padding: 20px; }
    
    .card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 25px;
        margin-bottom: 20px;
        position: relative;
        overflow: hidden;
    }
    
    .card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent);
        transform: scaleX(0);
        transition: transform 0.3s ease;
    }
    
    .card:hover::before { transform: scaleX(1); }
    
    .card h2 {
        color: var(--accent);
        margin-bottom: 20px;
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .role-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
    }
    
    .role-btn {
        padding: 30px 20px;
        background: var(--bg-secondary);
        border: 2px solid var(--border);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
        position: relative;
    }
    
    .role-btn:hover, .role-btn.active {
        border-color: var(--accent);
        background: rgba(0, 255, 65, 0.1);
        transform: translateY(-3px);
        box-shadow: 0 10px 20px rgba(0, 255, 65, 0.2);
    }
    
    .role-icon { font-size: 2rem; margin-bottom: 10px; }
    .role-title { font-size: 1.2rem; font-weight: 600; margin-bottom: 5px; color: var(--text); }
    .role-desc { font-size: 0.9rem; color: var(--text-dim); }
    
    .setup { display: none; }
    .setup.show { display: block; }
    
    .step {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 20px;
        margin-bottom: 15px;
    }
    
    .step-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        color: var(--accent);
        font-weight: 600;
    }
    
    .step-num {
        background: var(--accent);
        color: var(--bg-primary);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 700;
    }
    
    .code-display {
        background: var(--bg-primary);
        border: 1px solid var(--accent);
        border-radius: 6px;
        padding: 15px;
        margin: 10px 0;
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.8rem;
        word-break: break-all;
        max-height: 150px;
        overflow-y: auto;
        display: none;
    }
    
    .code-display.show { display: block; }
    
    .file-drop {
        border: 2px dashed var(--border);
        border-radius: 8px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        margin-bottom: 15px;
    }
    
    .file-drop:hover, .file-drop.has-files, .file-drop.dragover {
        border-color: var(--accent);
        background: rgba(0, 255, 65, 0.05);
    }
    
    .file-input { 
        position: absolute; 
        top: 0;
        left: 0;
        width: 100%; 
        height: 100%; 
        opacity: 0; 
        cursor: pointer; 
    }
    
    /* Individual file transfer displays */
    .transfer-list {
        margin-top: 20px;
    }
    
    .transfer-item {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
    }
    
    .transfer-item.sending {
        border-left: 4px solid #ff6b35;
    }
    
    .transfer-item.receiving {
        border-left: 4px solid var(--accent);
    }
    
    .transfer-item.completed {
        border-left: 4px solid var(--success);
        opacity: 0.8;
    }
    
    .transfer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .transfer-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .transfer-name {
        font-weight: 600;
        color: var(--text);
        font-size: 0.9rem;
    }
    
    .transfer-type {
        font-size: 0.8rem;
        color: var(--text-dim);
    }
    
    .transfer-type.sending { color: #ff6b35; }
    .transfer-type.receiving { color: var(--accent); }
    
    .transfer-size {
        font-size: 0.8rem;
        color: var(--text-dim);
    }
    
    .transfer-progress {
        background: var(--bg-primary);
        border-radius: 4px;
        height: 6px;
        margin: 8px 0;
        overflow: hidden;
    }
    
    .transfer-progress-bar {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
    }
    
    .transfer-progress-bar.sending {
        background: linear-gradient(90deg, #ff6b35, #ff8c42);
    }
    
    .transfer-progress-bar.receiving {
        background: linear-gradient(90deg, var(--accent), var(--accent-dim));
    }
    
    .transfer-stats {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
        font-size: 0.8rem;
    }
    
    .transfer-stat {
        text-align: center;
    }
    
    .transfer-stat-label {
        color: var(--text-dim);
        margin-bottom: 2px;
    }
    
    .transfer-stat-value {
        color: var(--text);
        font-weight: 600;
    }
    
    .connection-status {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 15px;
        background: var(--bg-secondary);
        border-radius: 6px;
        margin: 15px 0;
        display: none;
    }
    
    .connection-status.show { display: flex; }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--text-dim);
        transition: all 0.3s ease;
    }
    
    .status-dot.connected { background: var(--success); box-shadow: 0 0 10px var(--success); }
    .status-dot.connecting { background: var(--warning); animation: blink 1s infinite; }
    .status-dot.disconnected { background: var(--error); }
    
    .file-list { margin-top: 20px; }
    .file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        margin-bottom: 10px;
    }
    
    .mobile-warning {
        background: rgba(255, 170, 0, 0.1);
        border: 1px solid var(--warning);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
        color: var(--warning);
        display: none;
    }
    
    .mobile-warning.show { display: block; }
    
    @media (max-width: 768px) {
        .role-grid { grid-template-columns: 1fr; }
        .transfer-stats { grid-template-columns: 1fr; }
    }
</style>
{% endblock %}

{% block content %}
<div class="header">
    <nav class="container nav">
        <a href="/" class="logo">AnonShare</a>
        <a href="/" class="nav-link">‚Üê Home</a>
    </nav>
</div>

<div class="app">
    <div class="mobile-warning" id="mobileWarning">
        <strong>üì± Mobile:</strong> Use share buttons for codes. Keep tab active during transfers.
    </div>

    <!-- Role Selection -->
    <div class="card" id="roleCard">
        <h2>üöÄ Choose Role</h2>
        <div class="role-grid">
            <div class="role-btn" id="senderBtn">
                <div class="role-icon">üì§</div>
                <div class="role-title">Sender</div>
                <div class="role-desc">Send files</div>
            </div>
            <div class="role-btn" id="receiverBtn">
                <div class="role-icon">üì•</div>
                <div class="role-title">Receiver</div>
                <div class="role-desc">Receive files</div>
            </div>
        </div>
    </div>

    <!-- Connection Setup -->
    <div class="card setup" id="setupCard">
        <h2 id="setupTitle">üîó Setup</h2>
        
        <!-- Sender -->
        <div id="senderSetup" style="display: none;">
            <div class="step">
                <div class="step-header">
                    <div class="step-num">1</div>
                    <span>Create Offer</span>
                </div>
                <button id="createOfferBtn" class="btn btn-primary">Generate Code</button>
                <div class="code-display" id="offerDisplay">
                    <div id="offerText"></div>
                    <button id="copyOfferBtn" class="btn">üìã Copy</button>
                </div>
            </div>
            
            <div class="step" id="answerStep" style="display: none;">
                <div class="step-header">
                    <div class="step-num">2</div>
                    <span>Paste Answer</span>
                </div>
                <textarea id="answerInput" placeholder="Paste answer code..."></textarea>
                <button id="setAnswerBtn" class="btn">Connect</button>
            </div>
        </div>
        
        <!-- Receiver -->
        <div id="receiverSetup" style="display: none;">
            <div class="step">
                <div class="step-header">
                    <div class="step-num">1</div>
                    <span>Paste Offer</span>
                </div>
                <textarea id="offerInput" placeholder="Paste offer code..."></textarea>
                <button id="setOfferBtn" class="btn btn-primary">Generate Answer</button>
            </div>
            
            <div class="step">
                <div class="step-header">
                    <div class="step-num">2</div>
                    <span>Share Answer</span>
                </div>
                <div class="code-display" id="answerDisplay">
                    <div id="answerText"></div>
                    <button id="copyAnswerBtn" class="btn">üìã Copy</button>
                </div>
            </div>
        </div>
        
        <div class="connection-status" id="connectionStatus">
            <div class="status-dot" id="statusDot"></div>
            <span>Status: <strong id="statusText">Disconnected</strong></span>
        </div>
        
        <button id="resetBtn" class="btn">Reset</button>
    </div>

    <!-- File Transfer -->
    <div class="card setup" id="transferCard">
        <h2>üìÅ Transfer</h2>
        
        <div class="file-drop" id="fileDrop">
            <input type="file" id="fileInput" class="file-input" multiple>
            <div id="dropText">üìé Drop files or click to select</div>
        </div>
        
        <button id="sendBtn" class="btn btn-primary" disabled>Send Files</button>
        
        <!-- Active Transfers -->
        <div class="transfer-list" id="transferList">
            <h3 style="color: var(--accent); margin-bottom: 15px; display: none;" id="transfersTitle">üìä Active Transfers</h3>
            <div id="activeTransfers"></div>
        </div>
        
        <div class="file-list" id="fileList">
            <h3>üì• Received Files</h3>
            <div id="receivedFiles"></div>
        </div>
    </div>
    
    <div id="statusMsg" class="status"></div>
</div>
{% endblock %}

{% block extra_js %}
<script>
class P2P {
    constructor() {
        this.pc = null;
        this.dc = null;
        this.role = null;
        this.isInit = false;
        this.chunkSize = 64 * 1024; // Reduced to 16KB for better reliability
        this.sendDelay = 1; // Reduced delay for faster sending
        
        // Multi-file transfer management
        this.activeTransfers = new Map(); // fileId -> transfer data
        this.fileCounter = 0;
        this.messageQueue = []; // Queue for reliable message delivery
        this.isProcessingQueue = false;
        
        this.init();
    }

    init() {
        if (this.isMobile()) {
            document.getElementById('mobileWarning').classList.add('show');
            this.setupMobileSharing();
        }
        
        // Event listeners
        document.getElementById('senderBtn').onclick = () => this.selectRole('sender');
        document.getElementById('receiverBtn').onclick = () => this.selectRole('receiver');
        document.getElementById('resetBtn').onclick = () => this.reset();
        
        document.getElementById('createOfferBtn').onclick = () => this.createOffer();
        document.getElementById('setOfferBtn').onclick = () => this.setOffer();
        document.getElementById('setAnswerBtn').onclick = () => this.setAnswer();
        document.getElementById('copyOfferBtn').onclick = () => this.copy('offerText');
        document.getElementById('copyAnswerBtn').onclick = () => this.copy('answerText');
        
        document.getElementById('sendBtn').onclick = () => this.sendFiles();
        document.getElementById('fileInput').onchange = e => this.handleFiles(e.target.files);
        
        // Drag & drop
        const drop = document.getElementById('fileDrop');
        
        drop.ondragover = e => {
            e.preventDefault();
            drop.classList.add('dragover');
        };
        
        drop.ondragleave = e => {
            e.preventDefault();
            drop.classList.remove('dragover');
        };
        
        drop.ondrop = e => {
            e.preventDefault();
            drop.classList.remove('dragover');
            
            if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const dt = new DataTransfer();
                Array.from(e.dataTransfer.files).forEach(file => dt.items.add(file));
                
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.files = dt.files;
                }
                
                this.handleFiles(e.dataTransfer.files);
            }
        };
    }

    generateFileId() {
        return `file_${Date.now()}_${++this.fileCounter}`;
    }

    // Queue system for reliable message delivery
    queueMessage(message) {
        this.messageQueue.push(message);
        this.processQueue();
    }

    async processQueue() {
        if (this.isProcessingQueue || !this.dc || this.dc.readyState !== 'open') {
            return;
        }

        this.isProcessingQueue = true;

        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            
            try {
                // Check buffer before sending
                if (this.dc.bufferedAmount > 1024 * 1024) { // 1MB buffer limit
                    // Put message back and wait
                    this.messageQueue.unshift(message);
                    await this.waitForBuffer();
                    continue;
                }

                this.dc.send(message);
                
                // Small delay between messages to prevent overwhelming
                await new Promise(resolve => setTimeout(resolve, 1));
                
            } catch (error) {
                console.error('Error sending message:', error);
                // Put message back for retry
                this.messageQueue.unshift(message);
                break;
            }
        }

        this.isProcessingQueue = false;
    }

    waitForBuffer() {
        return new Promise(resolve => {
            const checkBuffer = () => {
                if (this.dc.bufferedAmount < 512 * 1024) { // Wait for buffer to be under 512KB
                    resolve();
                } else {
                    setTimeout(checkBuffer, 100);
                }
            };
            checkBuffer();
        });
    }

    createTransferUI(fileId, fileName, fileSize, type) {
        const transfersContainer = document.getElementById('activeTransfers');
        const transfersTitle = document.getElementById('transfersTitle');
        
        // Show transfers section
        transfersTitle.style.display = 'block';
        
        const transferItem = document.createElement('div');
        transferItem.className = `transfer-item ${type}`;
        transferItem.id = `transfer_${fileId}`;
        
        transferItem.innerHTML = `
            <div class="transfer-header">
                <div class="transfer-info">
                    <div class="transfer-name">${fileName}</div>
                    <div class="transfer-type ${type}">${type === 'sending' ? 'üì§ Sending' : 'üì• Receiving'}</div>
                </div>
                <div class="transfer-size">${this.formatSize(fileSize)}</div>
            </div>
            <div class="transfer-progress">
                <div class="transfer-progress-bar ${type}" id="progress_${fileId}"></div>
            </div>
            <div class="transfer-stats">
                <div class="transfer-stat">
                    <div class="transfer-stat-label">Speed</div>
                    <div class="transfer-stat-value" id="speed_${fileId}">0 MB/s</div>
                </div>
                <div class="transfer-stat">
                    <div class="transfer-stat-label">Progress</div>
                    <div class="transfer-stat-value" id="percent_${fileId}">0%</div>
                </div>
                <div class="transfer-stat">
                    <div class="transfer-stat-label">ETA</div>
                    <div class="transfer-stat-value" id="eta_${fileId}">--:--</div>
                </div>
            </div>
        `;
        
        transfersContainer.appendChild(transferItem);
        return transferItem;
    }

    updateTransferProgress(fileId, progress, transferred, totalSize, speed = 0, eta = 0) {
        const progressBar = document.getElementById(`progress_${fileId}`);
        const speedEl = document.getElementById(`speed_${fileId}`);
        const percentEl = document.getElementById(`percent_${fileId}`);
        const etaEl = document.getElementById(`eta_${fileId}`);
        
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (speedEl) speedEl.textContent = `${speed.toFixed(2)} MB/s`;
        if (percentEl) percentEl.textContent = `${Math.round(progress)}%`;
        if (etaEl) etaEl.textContent = this.formatTime(eta);
    }

    completeTransfer(fileId) {
        const transferItem = document.getElementById(`transfer_${fileId}`);
        if (transferItem) {
            transferItem.classList.add('completed');
            
            // Remove after 5 seconds
            setTimeout(() => {
                transferItem.remove();
                
                // Hide transfers section if empty
                const activeTransfers = document.getElementById('activeTransfers');
                const transfersTitle = document.getElementById('transfersTitle');
                if (activeTransfers.children.length === 0) {
                    transfersTitle.style.display = 'none';
                }
            }, 5000);
        }
        
        // Clean up transfer data
        this.activeTransfers.delete(fileId);
    }

    isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    setupMobileSharing() {
        if (navigator.share) {
            document.getElementById('copyOfferBtn').innerHTML = 'üì§ Share';
            document.getElementById('copyAnswerBtn').innerHTML = 'üì§ Share';
        }
    }

    selectRole(role) {
        this.role = role;
        this.isInit = role === 'sender';
        
        document.getElementById('roleCard').style.display = 'none';
        document.getElementById('setupCard').classList.add('show');
        document.getElementById('setupTitle').textContent = `üîó ${role.charAt(0).toUpperCase() + role.slice(1)} Setup`;
        document.getElementById(`${role}Setup`).style.display = 'block';
        document.getElementById('connectionStatus').classList.add('show');
        
        this.setupPC();
    }

    reset() {
        if (this.pc) this.pc.close();
        this.pc = this.dc = this.role = null;
        this.isInit = false;
        
        // Clear active transfers
        this.activeTransfers.clear();
        this.messageQueue = [];
        this.isProcessingQueue = false;
        document.getElementById('activeTransfers').innerHTML = '';
        document.getElementById('transfersTitle').style.display = 'none';
        
        document.getElementById('setupCard').classList.remove('show');
        document.getElementById('transferCard').classList.remove('show');
        document.getElementById('roleCard').style.display = 'block';
        
        ['senderSetup', 'receiverSetup', 'answerStep', 'offerDisplay', 'answerDisplay'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
        });
        
        ['offerInput', 'answerInput', 'offerText', 'answerText'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.value = '';
        });
        
        const fileInput = document.getElementById('fileInput');
        const dropText = document.getElementById('dropText');
        const fileDrop = document.getElementById('fileDrop');
        
        if (fileInput) fileInput.value = '';
        if (dropText) dropText.textContent = 'üìé Drop files or click to select';
        if (fileDrop) fileDrop.classList.remove('has-files');
        
        this.updateStatus('disconnected');
    }

    setupPC() {
        this.pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        });

        this.pc.onicecandidate = e => {
            if (!e.candidate) this.onIceComplete();
        };

        this.pc.ondatachannel = e => this.setupDC(e.channel);
        this.pc.onconnectionstatechange = () => this.updateStatus(this.pc.connectionState);
    }

    async createOffer() {
        try {
            this.dc = this.pc.createDataChannel('files', { 
                ordered: true,
                maxRetransmits: 3
            });
            this.setupDC(this.dc);
            
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);
            
            this.showStatus('Creating offer...', 'warning');
            this.updateStatus('connecting');
        } catch (e) {
            this.showStatus('Failed to create offer: ' + e.message, 'error');
        }
    }

    onIceComplete() {
        if (this.isInit && this.pc.localDescription) {
            document.getElementById('offerText').textContent = JSON.stringify(this.pc.localDescription);
            document.getElementById('offerDisplay').classList.add('show');
            document.getElementById('answerStep').style.display = 'block';
            this.showStatus('Offer generated! Share with receiver.', 'success');
        } else if (!this.isInit && this.pc.localDescription) {
            document.getElementById('answerText').textContent = JSON.stringify(this.pc.localDescription);
            document.getElementById('answerDisplay').classList.add('show');
            this.showStatus('Answer generated! Share with sender.', 'success');
        }
    }

    async setOffer() {
        try {
            const text = document.getElementById('offerInput').value.trim();
            if (!text) return this.showStatus('Paste offer code first.', 'error');
            
            await this.pc.setRemoteDescription(JSON.parse(text));
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);
            
            this.showStatus('Processing offer...', 'warning');
            this.updateStatus('connecting');
        } catch (e) {
            this.showStatus('Failed to set offer: ' + e.message, 'error');
        }
    }

    async setAnswer() {
        try {
            const text = document.getElementById('answerInput').value.trim();
            if (!text) return this.showStatus('Paste answer code first.', 'error');
            
            await this.pc.setRemoteDescription(JSON.parse(text));
            this.showStatus('Connecting...', 'warning');
        } catch (e) {
            this.showStatus('Failed to set answer: ' + e.message, 'error');
        }
    }

    setupDC(channel) {
        this.dc = channel;
        
        // Set buffer threshold for flow control
        channel.bufferedAmountLowThreshold = 512 * 1024; // 512KB
        
        channel.onopen = () => {
            this.updateStatus('connected');
            document.getElementById('transferCard').classList.add('show');
            this.showStatus('Connected! Ready to transfer.', 'success');
            this.updateSendBtn();
        };
        
        channel.onclose = () => this.updateStatus('disconnected');
        
        channel.onerror = e => {
            console.error('DC error:', e);
            this.showStatus('Data channel error occurred', 'error');
        };
        
        channel.onbufferedamountlow = () => {
            // Resume processing queue when buffer is low
            this.processQueue();
        };
        
        channel.onmessage = e => this.handleMsg(e.data);
    }

    async copy(elementId) {
        const text = document.getElementById(elementId).textContent;
        
        if (this.isMobile() && navigator.share) {
            try {
                await navigator.share({
                    title: 'AnonShare Code',
                    text: `AnonShare connection code:\n\n${text}`,
                    url: window.location.origin
                });
                this.showStatus('Shared successfully!', 'success');
            } catch (e) {
                this.fallbackCopy(text);
            }
        } else {
            this.fallbackCopy(text);
        }
    }

    async fallbackCopy(text) {
        try {
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(text);
            } else {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                ta.remove();
            }
            this.showStatus('Copied to clipboard!', 'success');
        } catch (e) {
            this.showStatus('Copy failed', 'error');
        }
    }

    handleFiles(files) {
        const dropText = document.getElementById('dropText');
        const fileDrop = document.getElementById('fileDrop');
        
        if (files && files.length > 0) {
            if (dropText) dropText.textContent = `üìé ${files.length} file(s) selected`;
            if (fileDrop) fileDrop.classList.add('has-files');
        } else {
            if (dropText) dropText.textContent = 'üìé Drop files or click to select';
            if (fileDrop) fileDrop.classList.remove('has-files');
        }
        this.updateSendBtn();
    }

    updateSendBtn() {
        const btn = document.getElementById('sendBtn');
        const fileInput = document.getElementById('fileInput');
        
        if (!btn) return;
        
        if (!fileInput) {
            btn.disabled = true;
            return;
        }
        
        const files = fileInput.files;
        btn.disabled = !this.dc || this.dc.readyState !== 'open' || !files || files.length === 0;
    }

    sendFiles() {
        const fileInput = document.getElementById('fileInput');
        if (!fileInput || !fileInput.files) {
            this.showStatus('No files selected', 'error');
            return;
        }
        
        const files = fileInput.files;
        if (this.dc?.readyState === 'open' && files.length > 0) {
            Array.from(files).forEach(f => this.sendFile(f));
        } else {
            this.showStatus('Connection not ready or no files selected', 'error');
        }
    }

    sendFile(file) {
        const fileId = this.generateFileId();
        const reader = new FileReader();
        let offset = 0;

        // Create transfer UI
        this.createTransferUI(fileId, file.name, file.size, 'sending');

        // Store transfer data
        const transferData = {
            fileId,
            fileName: file.name,
            fileSize: file.size,
            transferStart: Date.now(),
            lastUpdate: Date.now(),
            lastTransferred: 0,
            type: 'sending'
        };
        
        this.activeTransfers.set(fileId, transferData);

        // Send file metadata as JSON
        const metadata = JSON.stringify({
            type: 'start',
            fileId: fileId,
            name: file.name,
            size: file.size,
            mime: file.type
        });
        
        this.queueMessage(metadata);

        const send = () => {
            const slice = file.slice(offset, offset + this.chunkSize);
            reader.readAsArrayBuffer(slice);
        };

        reader.onload = e => {
            try {
                // Send binary data directly (not as JSON)
                const chunkData = new Uint8Array(e.target.result);
                
                // Create a header with fileId and send as binary
                const header = new TextEncoder().encode(`${fileId}:`);
                const combined = new Uint8Array(header.length + chunkData.length);
                combined.set(header, 0);
                combined.set(chunkData, header.length);
                
                this.queueMessage(combined.buffer);
                
                offset += e.target.result.byteLength;
                const progress = (offset / file.size) * 100;
                
                // Update progress
                const now = Date.now();
                const timeDiff = (now - transferData.lastUpdate) / 1000;
                const bytesDiff = offset - transferData.lastTransferred;
                
                if (timeDiff >= 0.5) {
                    const speed = bytesDiff / timeDiff / (1024 * 1024);
                    const remaining = file.size - offset;
                    const eta = speed > 0 ? remaining / (speed * 1024 * 1024) : 0;
                    
                    this.updateTransferProgress(fileId, progress, offset, file.size, speed, eta);
                    
                    transferData.lastUpdate = now;
                    transferData.lastTransferred = offset;
                }

                if (offset < file.size) {
                    setTimeout(send, this.sendDelay);
                } else {
                    // Send end marker as JSON
                    const endMessage = JSON.stringify({ 
                        type: 'end', 
                        fileId: fileId 
                    });
                    
                    this.queueMessage(endMessage);
                    this.completeTransfer(fileId);
                    this.showStatus(`File "${file.name}" sent!`, 'success');
                }
            } catch (e) {
                this.completeTransfer(fileId);
                this.showStatus('Send error', 'error');
            }
        };

        send();
    }

    handleMsg(data) {
        try {
            if (typeof data === 'string') {
                // Handle JSON messages (metadata)
                const msg = JSON.parse(data);
                
                if (msg.type === 'start') {
                    const fileId = msg.fileId;
                    
                    // Create transfer UI for receiving
                    this.createTransferUI(fileId, msg.name, msg.size, 'receiving');
                    
                    // Store receive data
                    const transferData = {
                        fileId,
                        fileName: msg.name,
                        fileSize: msg.size,
                        mimeType: msg.mime,
                        chunks: [],
                        received: 0,
                        transferStart: Date.now(),
                        lastUpdate: Date.now(),
                        lastTransferred: 0,
                        type: 'receiving'
                    };
                    
                    this.activeTransfers.set(fileId, transferData);
                    
                } else if (msg.type === 'end') {
                    const fileId = msg.fileId;
                    const transferData = this.activeTransfers.get(fileId);
                    
                    if (transferData && transferData.chunks.length > 0) {
                        const blob = new Blob(transferData.chunks, { type: transferData.mimeType });
                        this.addFile(transferData.fileName, blob);
                        this.completeTransfer(fileId);
                        this.showStatus(`File "${transferData.fileName}" received!`, 'success');
                    }
                }
            } else {
                // Handle binary data (file chunks)
                const arrayBuffer = data instanceof ArrayBuffer ? data : data.buffer;
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Extract fileId from header
                const headerEnd = uint8Array.indexOf(58); // ':' character
                if (headerEnd === -1) return;
                
                const fileId = new TextDecoder().decode(uint8Array.slice(0, headerEnd));
                const chunkData = uint8Array.slice(headerEnd + 1);
                
                const transferData = this.activeTransfers.get(fileId);
                if (transferData) {
                    transferData.chunks.push(chunkData);
                    transferData.received += chunkData.byteLength;
                    
                    const progress = (transferData.received / transferData.fileSize) * 100;
                    
                    // Update progress
                    const now = Date.now();
                    const timeDiff = (now - transferData.lastUpdate) / 1000;
                    const bytesDiff = transferData.received - transferData.lastTransferred;
                    
                    if (timeDiff >= 0.5) {
                        const speed = bytesDiff / timeDiff / (1024 * 1024);
                        const remaining = transferData.fileSize - transferData.received;
                        const eta = speed > 0 ? remaining / (speed * 1024 * 1024) : 0;
                        
                        this.updateTransferProgress(fileId, progress, transferData.received, transferData.fileSize, speed, eta);
                        
                        transferData.lastUpdate = now;
                        transferData.lastTransferred = transferData.received;
                    }
                }
            }
        } catch (e) {
            console.error('Message error:', e);
        }
    }

    addFile(name, blob) {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <div>
                <div style="font-weight: 600;">${name}</div>
                <div style="font-size: 0.8rem; color: var(--text-dim);">${this.formatSize(blob.size)}</div>
            </div>
            <button class="btn">‚¨á Download</button>
        `;
        
        item.querySelector('button').onclick = () => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            a.click();
            URL.revokeObjectURL(url);
        };
        
        document.getElementById('receivedFiles').appendChild(item);
    }

    updateStatus(status) {
        const dot = document.getElementById('statusDot');
        const text = document.getElementById('statusText');
        
        if (dot) dot.className = `status-dot ${status}`;
        if (text) text.textContent = status.charAt(0).toUpperCase() + status.slice(1);
    }

    showStatus(msg, type) {
        const status = document.getElementById('statusMsg');
        if (status) {
            status.textContent = msg;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => status.style.display = 'none', 3000);
            }
        }
    }

    formatSize(bytes) {
        if (!bytes) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    formatTime(seconds) {
        if (!seconds || !isFinite(seconds)) return '--:--';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
}

document.addEventListener('DOMContentLoaded', () => new P2P());
</script>
{% endblock %}
